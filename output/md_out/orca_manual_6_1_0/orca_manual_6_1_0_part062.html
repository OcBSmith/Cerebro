<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8"/>
<title>orca_manual_6_1_0_part062</title>
<meta name="generator" content="Docling HTML Serializer"/>
<style>
    html {
        background-color: #f5f5f5;
        font-family: Arial, sans-serif;
        line-height: 1.6;
    }
    body {
        max-width: 800px;
        margin: 0 auto;
        padding: 2rem;
        background-color: white;
        box-shadow: 0 0 10px rgba(0,0,0,0.1);
    }
    h1, h2, h3, h4, h5, h6 {
        color: #333;
        margin-top: 1.5em;
        margin-bottom: 0.5em;
    }
    h1 {
        font-size: 2em;
        border-bottom: 1px solid #eee;
        padding-bottom: 0.3em;
    }
    table {
        border-collapse: collapse;
        margin: 1em 0;
        width: 100%;
    }
    th, td {
        border: 1px solid #ddd;
        padding: 8px;
        text-align: left;
    }
    th {
        background-color: #f2f2f2;
        font-weight: bold;
    }
    figure {
        margin: 1.5em 0;
        text-align: center;
    }
    figcaption {
        color: #666;
        font-style: italic;
        margin-top: 0.5em;
    }
    img {
        max-width: 100%;
        height: auto;
    }
    pre {
        background-color: #f6f8fa;
        border-radius: 3px;
        padding: 1em;
        overflow: auto;
    }
    code {
        font-family: monospace;
        background-color: #f6f8fa;
        padding: 0.2em 0.4em;
        border-radius: 3px;
    }
    pre code {
        background-color: transparent;
        padding: 0;
    }
    .formula {
        text-align: center;
        padding: 0.5em;
        margin: 1em 0;
        background-color: #f9f9f9;
    }
    .formula-not-decoded {
        text-align: center;
        padding: 0.5em;
        margin: 1em 0;
        background: repeating-linear-gradient(
            45deg,
            #f0f0f0,
            #f0f0f0 10px,
            #f9f9f9 10px,
            #f9f9f9 20px
        );
    }
    .page-break {
        page-break-after: always;
        border-top: 1px dashed #ccc;
        margin: 2em 0;
    }
    .key-value-region {
        background-color: #f9f9f9;
        padding: 1em;
        border-radius: 4px;
        margin: 1em 0;
    }
    .key-value-region dt {
        font-weight: bold;
    }
    .key-value-region dd {
        margin-left: 1em;
        margin-bottom: 0.5em;
    }
    .form-container {
        border: 1px solid #ddd;
        padding: 1em;
        border-radius: 4px;
        margin: 1em 0;
    }
    .form-item {
        margin-bottom: 0.5em;
    }
    .image-classification {
        font-size: 0.9em;
        color: #666;
        margin-top: 0.5em;
    }
</style>
</head>
<body>
<div class='page'>
<p>(continued from previous page)</p>
<pre><code>command=os.getenv("ORCA_COMMAND"), deleteJobFiles= False , header="bp86 def2-svp qmmmopt/pdynamo", job="chignolin", run= True ) # Assign the models to the system. system.DefineMMModel(mmmodel) system.DefineQCModel( qcmodel, qcSelection=pCore.Selection([35, 36, 37, 34, 40, 41])) system.DefineNBModel(nbmodel) system.electronicState = pMolecule.ElectronicState( charge=-1, multiplicity=1) # Print a summary and calculate the energy. system.Summary() system.Energy()</code></pre>
<p>After the execution of the above Python program, a series of files are going to be created chignolin.inp , chignolin.pc , chignolin.lj and ORCA is going to be called. The generated ORCA input file is listed below.</p>
<pre><code>! bp86 def2-svp qmmmopt/pdynamo % geom constraints {C 0 C} {C 1 C} end end % pointcharges "chignolin.pc" % ljcoefficients "chignolin.lj" * xyz -1 1 H -1.0637532468 1.1350324675 2.4244220779 C -0.5230000000 0.6870000000 3.2490000000 C 0.4180000000 1.7240000000 3.8660000000 O -0.0690000000 2.7620000000 4.2830000000 O 1.6090000000 1.4630000000 3.9110000000 H -1.2240000000 0.3460000000 3.9970000000 H 0.0550000000 -0.1510000000 2.8890000000 *</code></pre>
<p>There are few points that have to be raised here. Because the keyword qmmm/pdynamo was specified in the header variable, the pDynamo library will automatically add the constraint block in the ORCA input, which will freeze the link atoms and the QM atoms to which they are bound. It will also generate the chignolin.lj file containing all the Lennard-Jones parameters. The important parts of this file, which is somewhat different than the one generated by Gromacs, are listed next.</p>
<pre><code># number of atoms combination rule 138 0 # x y z sigma epsilon id -6.778000 -1.424000 4.200000 3.250000 0.711280 -1 -6.878000 -0.708000 2.896000 3.500000 0.276144 -1 -5.557000 -0.840000 2.138000 3.750000 0.439320 -1 ... 0.433000 0.826000 0.502000 2.960000 0.878640 -1 -0.523000 0.687000 3.249000 3.500000 0.276144 1 0.418000 1.724000 3.866000 3.750000 0.439320 2 -0.069000 2.762000 4.283000 2.960000 0.878640 3 1.609000 1.463000 3.911000 2.960000 0.878640 4 -2.259000 -0.588000 1.846000 0.000000 0.000000 -1 -1.795000 2.207000 2.427000 2.500000 0.125520 -1 -1.224000 0.346000 3.997000 2.500000 0.125520 5</code></pre>
<p>(continues on next page)</p>
<p>(continued from previous page)</p>
<table><tbody><tr><td>0.055000 -0.311000 ...</td><td>-0.151000 2.922000</td><td>2.889000 0.557000</td><td>2.500000 3.250000</td><td>0.125520 0.711280</td><td>6 -1</td></tr><tr><td>-1.387000</td><td>-2.946000</td><td>5.106000</td><td>2.500000</td><td>0.125520</td><td>-1</td></tr><tr><td colspan="2"># number of special pairs 22</td><td></td><td></td><td></td><td></td></tr><tr><td># atom1</td><td>atom2 32</td><td>factor 0.000000</td><td></td><td></td><td></td></tr><tr><td>34</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>35</td><td>39</td><td>0.500000</td><td></td><td></td><td></td></tr><tr><td>40</td><td>31</td><td>0.000000</td><td></td><td></td><td></td></tr><tr><td>41</td><td>30</td><td>0.500000</td><td></td><td></td><td></td></tr><tr><td>41</td><td>32</td><td>0.500000</td><td></td><td></td><td></td></tr><tr><td>36</td><td>31</td><td>0.500000</td><td></td><td></td><td></td></tr><tr><td>40</td><td>32</td><td>0.500000</td><td></td><td></td><td></td></tr><tr><td>40 34</td><td>39</td><td>0.500000</td><td></td><td></td><td></td></tr><tr><td></td><td>31</td><td>0.000000</td><td></td><td></td><td></td></tr><tr><td>35 34</td><td>30 11</td><td>0.500000 0.500000</td><td></td><td></td><td></td></tr><tr><td>34 41</td><td>38 31</td><td>0.500000 0.000000</td><td></td><td></td><td></td></tr><tr><td>37</td><td>31</td><td>0.500000</td><td></td><td></td><td></td></tr><tr><td>34</td><td>33</td><td>0.500000</td><td></td><td></td><td></td></tr><tr><td>34</td><td>39</td><td>0.000000</td><td></td><td></td><td></td></tr><tr><td>40</td><td>30</td><td>0.500000</td><td></td><td></td><td></td></tr><tr><td>41</td><td>39</td><td>0.500000</td><td></td><td></td><td></td></tr><tr><td>34</td><td>30</td><td>0.000000</td><td></td><td></td><td></td></tr><tr><td>35</td><td>31</td><td>0.000000</td><td></td><td></td><td></td></tr><tr><td>34</td><td>42</td><td>0.500000</td><td></td><td></td><td></td></tr><tr><td>35</td><td>32</td><td>0.500000</td><td></td><td></td><td></td></tr></tbody></table>
<p>The second number on the first line refers to the type of combination rule used to calculate the Lennard-Jones interaction. It is 0 if a geometric average is used (OPLS force field), or 1 for the Lorentz-Berthelot rules (AMBER force field). The id on the last column is -1 for MM atoms and is equal to the atom number for the QM atoms. In this case the hydrogen link atom is atom 0. The last block of the file is composed of atom pairs and a special factor by which their Lennard-Jones interaction is scaled. In general this factor is equal to 1, but for atoms one or two bonds apart is zero, while for atoms three bonds apart depends on the type of force field, and in this case is 0.5.</p>
<p>After successful completion of the ORCA optimization run, the information will be relayed back the pDynamo library, which will report the total QM/MM energy of the system. At this point the type QM/MM of calculation is limited only by the capabilities of the pDynamo library, which are quite extensive.</p>
<h2>6.4.3 ORCA and NAMD</h2>
<p>Since version 2.12, NAMD is able to perform hybrid QM/MM calculations. A more detailed explanation of all available key words, setting up the calculation and information on tutorials and on the upcoming graphic interface to VMDare available on the NAMD website.</p>
<p>Similar to other calculations with NAMD, the QM/MM is using a pdb file to control the active regions. An example is shown below, where the sidechain of a histidine protonated at N ϵ is chosen to be the QM region. Either the occupancy column or the b-factor column of the file are used to indicate which atom are included in a QM area and which are treated by the forcefield. In the other column, atoms which are connecting the QM area and the MM part are indicated similarly. To clarify which column is used for which purpose, the keywords qmColumn and qmBondColumn have to be defined in the NAMD input.</p>
<pre><code>... ATOM 1737 CA HSE P 117 14.762 47.946 31.597 1.00 0.00 PROT C ATOM 1738 HA HSE P 117 14.751 47.579 32.616 0.00 0.00 PROT H ATOM 1739 CB HSE P 117 14.129 49.300 31.501 1.00 1.00 PROT C ATOM 1740 HB1 HSE P 117 14.407 49.738 30.518 0.00 1.00 PROT H</code></pre>
<p>(continues on next page)</p>
<p>(continued from previous page)</p>
<table><tbody><tr><td>ATOM</td><td>1741</td><td>HB2</td><td>HSE</td><td>P 117</td><td>13.024</td><td>49.194</td><td>31.509</td><td>0.00</td><td>1.00</td><td>PROT</td><td>H</td></tr><tr><td>ATOM</td><td>1742</td><td>ND1</td><td>HSE</td><td>P 117</td><td>13.899</td><td>51.381</td><td>32.779</td><td>0.00</td><td>1.00</td><td>PROT</td><td>N</td></tr><tr><td>ATOM</td><td>1743</td><td>CG</td><td>HSE</td><td>P 117</td><td>14.572</td><td>50.261</td><td>32.582</td><td>0.00</td><td>1.00</td><td>PROT</td><td>C</td></tr><tr><td>ATOM</td><td>1744</td><td>CE1</td><td>HSE</td><td>P 117</td><td>14.615</td><td>52.043</td><td>33.669</td><td>0.00</td><td>1.00</td><td>PROT</td><td>C</td></tr><tr><td>ATOM</td><td>1745</td><td>HE1</td><td>HSE</td><td>P 117</td><td>14.356</td><td>53.029</td><td>34.064</td><td>0.00</td><td>1.00</td><td>PROT</td><td>H</td></tr><tr><td>ATOM</td><td>1746</td><td>NE2</td><td>HSE</td><td>P 117</td><td>15.678</td><td>51.318</td><td>33.982</td><td>0.00</td><td>1.00</td><td>PROT</td><td>N</td></tr><tr><td>ATOM</td><td>1747</td><td>HE2</td><td>HSE</td><td>P 117</td><td>16.369</td><td>51.641</td><td>34.627</td><td>0.00</td><td>1.00</td><td>PROT</td><td>H</td></tr><tr><td>ATOM</td><td>1748</td><td>CD2</td><td>HSE</td><td>P 117</td><td>15.706</td><td>50.183</td><td>33.335</td><td>0.00</td><td>1.00</td><td>PROT</td><td>C</td></tr><tr><td>ATOM</td><td>1749</td><td>HD2</td><td>HSE</td><td>P 117</td><td>16.451</td><td>49.401</td><td>33.388</td><td>0.00</td><td>1.00</td><td>PROT</td><td>H</td></tr><tr><td>ATOM</td><td>1750</td><td>C</td><td>HSE</td><td>P 117</td><td>13.916</td><td>47.000</td><td>30.775</td><td>0.00</td><td>0.00</td><td>PROT</td><td>C</td></tr><tr><td>ATOM</td><td>1751</td><td>O</td><td>HSE</td><td>P 117</td><td>12.965</td><td>46.452</td><td>31.334</td><td>0.00</td><td>0.00</td><td>PROT</td><td>O</td></tr></tbody></table>
<h2>NOTES:</h2>
<ul>
<li style="list-style-type: '· ';">If one wants to include more than one QM region, integers bigger than 1 can be used to define the different regions.</li>
<li style="list-style-type: '· ';">Charge groups cannot be split when selecting QM and MM region. The reason is that non-integer partial charges may occur if a charge group is split. Since the QM partial charges are updated in every QM iteration, this may lead to a change in the total charge of the system over the course of the MD simulation.</li>
<li style="list-style-type: '· ';">The occupancy and b-factor columns are used for several declarations in NAMD. If two of these come together in one simulation, the keyword qmParamPDB is used to define which pdb file contains the information about QMatoms and bonds.</li>
<li style="list-style-type: '· ';">To simplify the selection of QM atoms and writing the pdb file a set of scripts is planned to be included in future releases of NAMD.</li>
</ul>
<p>To run the calculation, the keyword qmForces on must be set. To select ORCA qmSoftware "orca" must be specified and the path to the executables must be given to qmExecPath , as well as a directory where the calculation is carried out ( qmBaseDir ). To pass the method and specifications from NAMD to ORCA qmConfigLine is used. These lines will be copied to the beginning of the input file and can contain both simple input as well as block input. To ensure the calculation of the gradient, the engrad keyword should be used.</p>
<p>The geometry of the QM region including the selected links as well as the MM point charges are copied to the ORCA inputfile automatically. Multiplicity and charge can be defined using qmMult and qmCharge , although the latter can be determined automatically by NAMD using the MM parameters. It should be noted at this point that NAMD is capable to handle more than one QM region per QM/MM calculation. Therefore for each region, charge and multiplicity are expected. In the case of only one QM region, the input looks like the following:</p>
<p>qmMult qmCharge</p>
<p>"1</p>
<p>"1</p>
<p>1"</p>
<p>0"</p>
<p>Currently, two charge modes are available: Mulliken and CHELPG. They have to be specified in the NAMD input using QMChargeMode and in the qmConfigLine , respectively. Different embedding schemes, point charge schemes and switching functions are available, which will be not further discussed here. Another useful tool worth mentioning is the possibility to call secondary executables before the first or after each QM software execution using QMPrepProc or QMSecProc , respectively. Both are called with the complete path and name to the QM input file, allowing e.g. storage of values during an QM/MM-MD.</p>
<p>It is strongly emphasized that at this points both programs are constantly developed further. For the latest information, either the ORCA forum or the NAMD website should be consulted.</p>
<h2>6.5 Fast Multipole Method</h2>
<p>The Fast Multipole Method (FMM) algorithm was proposed in the 1980s[797], to reduce the computation time for two-centre interactions in large systems, by moving from a quadratic relationship (O( N 2 )) to a quasi-linear relationship (O ( Nlog ( N )) ) of the computation time with the number N of particles (atoms, point charges, etc.). This algorithm is particularly useful for long-range interactions that are difficult to ignore, such as the Coulombic interaction (1/r) which is fundamental to any system but grows quadratically with the number of centers.</p>
<p>The FMM is used in ORCA for accelerating QMMM calculations in the scope of electrostatic embedding: FMMQMMM(cf. Embedding Types ).</p>
<h2>6.5.1 The Octree hierarchy</h2>
<p>There exists a lot of detailed and pedagogical literature on the subject (we recommend for instance [801] and [802]). In the following we will only describe the main parameters.</p>
<p>The idea of the algorithm is to divide space to handle differently short- and long-range interactions. The latter will be approximated (cf. Fast Multipole Method ). To do so, the whole system is placed in a cubic box which is iteratively divided in 8 children boxes (forming levels L: L = 0 → L = Lmax) so as to form a structure called an Octree (see Fig. Fig. 6.4).</p>
<figure><figcaption><div class="caption">Fig. 6.4: Division of the system into boxes, schematic representation in 2D.</div></figcaption></figure>
<p>At the deepest level, L = Lmax, for every box, we can define a layer of nearest neighbours boxes (NN) which will be responsible for the Near-Field (NF, i.e.short-range). The electrostatic potential due to the rest of the boxes is define as the Far-Field (FF, i.e. long-range).</p>
<div class="formula-not-decoded">Formula not decoded</div>
<p>As visible on Figure Fig. 6.4, one can divide the FF area between a Local Far Field (LFF, green) area and a Remote Far Field area (RFF, grey), so that a recursive scheme between levels appears:</p>
<div class="formula-not-decoded">Formula not decoded</div>
<p>The LFF boxes are the boxes in the NF of the parent but not in the NF of the children, that represents a maximum of 189 boxes. The RFF potential is due to boxes which actually represent the FF area of the parent box of B. This</p>
<p>means that one needs to calculate only the LFF term at every level, the rest of the potential will be inherited from the parent box.</p>
<p>The number of levels, Lmax, can be setup in the input directly (FMMQMMM_Levels), or will be deduced from the provided box dimension (FMMQMMM_BoxDimInp, dimension of the box at Lmax). The second option (default) is recommended, with a box dimension around 9.0 Bohr (FMMQMMMM_BoxDimInp 9.0 ). If FM-MQMMM_DoBoxDimOpt option is turned to TRUE (default), the box dimension will be reduced as much as possible while keeping the same value of Lmax, this to ensure the algorithm works optimally regarding both accuracy and efficiency.</p>
<pre><code>%method DOFMMQMMM True #turn ON the use of the FMM FMMQMMM_BoxDimInp 9.0 #Higher boundary to set up the dimension (in Bohr!) FMMQMMM_DoBoxDimOpt True #Optimize the box dimension end</code></pre>
<p>The higher Lmax, the bigger the number of boxes: at L = 2 one has 64 boxes only but for L = 6 the code generates more than 200,000 boxes ( 8 6 ). For Lmax ≥ 7 , more than 2 millions boxes are generated, this can start leading to memory issues, so that the user should ensure enough memory is available (cf. Global Memory Use ).</p>
<h2>6.5.2 Approximation of the Far Field interactions</h2>
<p>In a space of origin O(0,0,0), let P ( r P ) be the center of a charge distribution (e.g. a Gaussian overlap or a distribution of point charges). Let's consider a point A in the vicinity of P, such that A = (q A ; r A ), with q A the charge of a point charge or q A = -1 if we consider a Gaussian overlap. In that case, the charge would indeed be the one of the electron situated at a position r AP = r A -r P from the center of the Gaussian overlap. Similarly, let Q ( r Q ) be the center of a charge distribution and B, a point in the vicinity of Q, such that B = (q B ; r B ). We note r QP = r Q -r P .</p>
<p>The Coulomb interaction between A and B can be expressed as:</p>
<div class="formula-not-decoded">Formula not decoded</div>
<p>The name of the algorithm comes from the way the FF interactions are evaluated. It is done through a mutlipole expansion of the 1 | r a -r b | term, leading to the following expression:</p>
<div class="formula-not-decoded">Formula not decoded</div>
<p>This series converges for well separated centers only, that is why a NF layer is required. R l,m and I l,m are regular and irregular solid scaled harmonics [803]:</p>
<div class="formula-not-decoded">Formula not decoded</div>
<p>Y l,m are spherical harmonics of degree l and order m . For details on the derivation of this equation see [801].</p>
<p>We can now introduce the multipole expansion centered in P ( r P ), of a charge distribution Q ( r , P ) , as:</p>
<div class="formula-not-decoded">Formula not decoded</div>
<div class="formula-not-decoded">Formula not decoded</div>
<p>In practise:</p>
<p>Q is a vector, with elements Q l,m defined by the pair of values ( l , m ). In the case of a point charge A (q A , r ) we have:</p>
<div class="formula-not-decoded">Formula not decoded</div>
<p>while for a Gaussian overlap distribution ⟨ µ | ν ⟩ it becomes:</p>
<div class="formula-not-decoded">Formula not decoded</div>
<p>So that we can approximate the electrostatic interaction between a Gaussian overlap ⟨ µ | ν ⟩ with center in r B and a point charge A (q A , r A ) in the FF, through the following expansion:</p>
<div class="formula-not-decoded">Formula not decoded</div>
<p>with P and P ' the respective center of the multipole expansions, and I the interaction matrix.</p>
<p>The truncation parameter of the expansion, MAM, is the Maximum Angular Momentum of the underlying solid scaled harmonics. In our setup, it is the same value for the expansion of the point charges in the embedding or the Gaussian overlaps in the QM part. It can be setup through the keyword FMMQMMM_MAM. We recommend FMMQMMM_MAM = 20 to ensure a good accuracy, in the order of 0.0001-0,0001 Ha. With a lower value of MAM=15, one can usually expect a mHa (0.63 kcal.mol -1 ) precision. However it is system dependent, so that we recommend you to start with MAM=20 and see how it behaves if you decrease it to a value of 15. The available values for MAM are in the range 1-25.</p>
<pre><code>%method DOFMMQMMM True #turn ON the use of the FMM FMMQMMM_MAM 20 #Default Maximum Angular Momentum end</code></pre>
<h2>6.5.3 The 'Very' Fast Multipole Method (VFMM)</h2>
<p>Due to the recursive scheme between levels, the FF felt in the center of a box is built by only calculating interactions with the LFF boxes at every level. The evaluation of V LFF becomes the bottleneck of the algorithm. To accelerate it, an option has been implemented in which different MAM truncation parameters will be used for all the (&gt;189) boxes in the LFF area. This option FMMQMMMM_DoVFMM is turned ON by default, but should be switched OFF whenever the MAM is smaller than 15, that would impact to much the accuracy without improving much the efficiency.</p>
<pre><code>%method DOFMMQMMM True #turn ON the use of the FMM FMMQMMM_DoVFMM True #Use the Very Fast Multipole Method end</code></pre>
<h2>6.5.4 Recommended input</h2>
<p>Whenever there is an electrostatic embedding, for systems containing more than 10,000 point charges (ECM) or MM atoms (QMMM), it is recommended to turn on the FMM in order to accelerate the calculation of the electrostatic potential. However, when using heavy parallelization with more than 24 processors, the impact of enabling the Fast Multipole Method (FMM) may be negligible for small embedding size.</p>
<pre><code>Ϫ Caution FMM-QMMM does not replace the QMMM keyword.</code></pre>
<p>The two elements one can play on are the truncation parameter of the expansion, MAM, and the box dimension at the deepest level (Lmax). Recommended/default parameters can be called in the keyword line directly using FMMQMMMor by setting the parameters accordingly in the %method block:</p>
<pre><code>#keyword line ! FMM-QMMM #OR through method block %method DOFMMQMMM True #turn ON the use of the FMM USEFMMQMMM True #turn ON the use of the FMM ###parameters: FMMQMMM_DoVFMM True #Use the Very Fast Multipole Method FMMQMMM_MAM 20 #Maximum Angular Momentum FMMQMMM_Levels 0 #Number of levels set to 0, will be set␣ ↪ → automatically by box dim FMMQMMM_BoxDimInp 9.0 #Higher boundary to set up the dimension (in Bohr!) FMMQMMM_DoBoxDimOpt True #Optimize the box dimension end</code></pre>
<p>The parameters used by the algorithm are printed in the output by default, we recomend you to check them in your first calculations:</p>
<pre><code>----------------------SHARK INTEGRAL PACKAGE ----------------------[...] Use FMM for one center integrals with PCs - - - - - - - FMM PARAMETERS- - - - - - num PCs 75894 VFMM USED MAM 20 Input box dim 9.000 Refined box dim 5.197 Tree depth/levels 6 - --------------------</code></pre>
<p>This can be turned off by modifying the relative printing options.</p>
<pre><code>%method FMMQMMM_Printing 1 # remove FMM PARMETERS printing, default value is 2 end</code></pre>
<h2>6.5.5 Some examples</h2>
<p>Call the recommanded FMM parameters through the keyword line:</p>
<pre><code>!QMMM wB97X-D3BJ RIJCOSX FMM-QMMM %qmmm ORCAFFFilename "file.prms" Embedding Electrostatic ChargeAlteration CS QMAtoms {2016:2026} end end</code></pre>
<p>(continues on next page)</p>
<pre><code>*pdbfile 0 1 file.pdb</code></pre>
<p>Change the MAM from 20 (value when one uses the keyword line) to 15, and use 5 levels:</p>
<pre><code>!QMMM wB97X-D3BJ RIJCOSX %method DOFMMQMMM True #turn ON the use of the FMM USEFMMQMMM True #turn ON the use of the FMM ###parameters: FMMQMMM_DoVFMM True #Use the Very Fast Multipole Method FMMQMMM_MAM 15 #Maximum Angular Momentum FMMQMMM_Levels 5 #number of levels end %qmmm ORCAFFFilename "file.prms" Embedding Electrostatic ChargeAlteration CS QMAtoms {2016:2026} end end *pdbfile 0 1 file.pdb</code></pre>
<h2>Specify the box dimension without optimizing it:</h2>
<pre><code>!QMMM wB97X-D3BJ RIJCOSX %method DOFMMQMMM True #turn ON the use of the FMM USEFMMQMMM True #turn ON the use of the FMM ###parameters: FMMQMMM_DoVFMM True #Use the Very Fast Multipole Method FMMQMMM_MAM 15 #Maximum Angular Momentum FMMQMMM_Levels 0 #number of levels FMMQMMM_BoxDimInp 9.0 #Higher boundary to set up the dimension (in Bohr!) FMMQMMM_DoBoxDimOpt False #Does not optimize the box dimension end %qmmm ORCAFFFilename "file.prms" Embedding Electrostatic ChargeAlteration CS QMAtoms {2016:2026} end end *pdbfile 0 1 file.pdb</code></pre>
<h2>Specifying the box dimension and ask to optimize it:</h2>
<pre><code>!QMMM wB97X-D3BJ RIJCOSX %method DOFMMQMMM True #turn ON the use of the FMM USEFMMQMMM True #turn ON the use of the FMM ###parameters: FMMQMMM_DoVFMM True #Use the Very Fast Multipole Method FMMQMMM_MAM 15 #Maximum Angular Momentum</code></pre>
<p>(continued from previous page)</p>
<p>(continues on next page)</p>
<p>(continued from previous page)</p>
<h2>7.1 Ab initio Molecular Dynamics</h2>
<p>Afewyears ago, we included an ab initio molecular dynamics (AIMD) module into ORCA. 1 As a plethora of different electron structure methods with analytical gradients is already implemented, all these methods are now available also for MD simulations, offering a wide range of accuracy/performance trade-offs.</p>
<p>Despite the relatively short history inside of the ORCA package, the MD module has grown considerably over the last years. A few features found in other MD codes are still missing. In future releases, many more new features and methods will (hopefully) be added to this part of the program. We will always do our best to keep a strict backward compatibility, such that the sample inputs from this section will remain valid in all future releases.</p>
<p>For some more information as well as input examples for the ORCA MD module, please visit https://brehm-research.de/orcamd</p>
<h2>7.1.1 Changes in ORCA 5.0</h2>
<ul>
<li style="list-style-type: '· ';">Added a Metadynamics module with many features and options:</li>
<li>-Can perform one-dimensional and two-dimensional Metadynamics simulations [804] to explore free energy profiles along reaction coordinates, called collective variables ('Colvars').</li>
<li>-Colvars can be distances (including projections onto vectors and into planes) , angles, dihedrals, and coordination numbers [805]. The latter allows, e. g. , to accurately compute p K A values of weak acids [806, 807].</li>
<li>-For all Colvars, groups of atoms (e. g., centers of mass) can be used instead of single atoms.</li>
<li>-Metadynamics simulations can be easily restarted and split over multiple runs.</li>
<li>-Ability to run well-tempered Metadynamics [808] for a smoothly converging free energy profile.</li>
<li>-Ability to run extended Langrangian Metadynamics [805], where a virtual particle on the bias profile is coupled to the real system via a spring. The virtual particle can be thermostated.</li>
<li style="list-style-type: '· ';">Added two modern and powerful thermostats (both available as global and massive) :</li>
<li>-The widely used Nosé-Hoover chain thermostat (NHC) with high-order Yoshida integrator [809, 810]; allows for a very accurate sampling of the canonical ensemble.</li>
<li>-The stochastical 'Canonical Sampling through Velocity Rescaling' (CSVR) thermostat [811] which has become quite popular recently.</li>
<li style="list-style-type: '· ';">Can define harmonic and Gaussian restraints for all Colvars (distance, angle, dihedral, coordination number) . This allows for umbrella sampling [812, 813], among other methods. Can also define one-sided restraints which act as lower or upper wall.</li>
</ul>
<p>1 Strictly speaking, these simulations are Born-Oppenheimer molecular dynamics simulations (BOMD), because they approximately solve the time-independent Schrödinger equation to compute gradients and then move the atoms according to these gradients.</p>
<h2>MOLECULAR DYNAMICS</h2>
<ul>
<li style="list-style-type: '· ';">Can now print the instantaneous and average force on constraints and restraints ; this allows for thermodynamic integration [813].</li>
<li style="list-style-type: '· ';">The target value for constraints and restraints can now be a ramp, so that it can linearly change during the simulation.</li>
<li style="list-style-type: '· ';">Can now keep the system's center of mass fixed during MD runs.</li>
<li style="list-style-type: '· ';">Can now print population analyses, orbital energies, and .engrad files in every MD step if requested.</li>
</ul>
<h2>7.1.2 Changes in ORCA 4.2 (Aug 2019)</h2>
<ul>
<li style="list-style-type: '· ';">Added a Cartesian minimization command to the MD module, based on L-BFGS and simulated annealing. Works for large systems ( &gt; 10 000 ) atoms and also with constraints. Offers a flag to only optimize hydrogen atom positions (for crystal structure refinement) . See Minimize command.</li>
<li style="list-style-type: '· ';">The MD module can now write trajectories in DCD file format (in addition to the already implemented XYZ and PDB formats) , see Dump command.</li>
<li style="list-style-type: '· ';">The thermostat is now able to apply temperature ramps during simulation runs.</li>
<li style="list-style-type: '· ';">Added more flexibility to region definition (can now add/remove atoms to/from existing regions) . Renamed the Define_Region command to Manage_Region .</li>
<li style="list-style-type: '· ';">Added two new constraint types which keeps centers of mass fixed or keep complete groups of atoms rigid, see Constraint command.</li>
<li style="list-style-type: '· ';">Ability to store the GBW file every n -th step during MD runs (e.g. for plotting orbitals along the trajectory) , see Dump command.</li>
<li style="list-style-type: '· ';">Can now set limit for maximum displacement of any atom in a MD step, which can stabilize dynamics with poor initial structures. Runs can be cleanly aborted by ' touch EXIT '. See Run command.</li>
<li style="list-style-type: '· ';">Better handling/reporting of non-converged SCF during MD runs.</li>
<li style="list-style-type: '· ';">Fixed an issue which slowed down molecular dynamics after many steps.</li>
<li style="list-style-type: '· ';">Stefan Grimme's xTB method can now be used in the MD module, allowing fast simulations of large systems.</li>
</ul>
<h2>7.1.3 Changes in ORCA 4.1 (Dec 2018)</h2>
<ul>
<li style="list-style-type: '· ';">Molecular dynamics simulation can now use Cartesian, distance, angle, and dihedral angle constraints. These are managed with the Constraint command.</li>
<li style="list-style-type: '· ';">The MD module now features cells of several geometries (cube, orthorhombic, parallelepiped, sphere, ellipsoid), which can help to keep the system inside of a well-defined volume. The cells have repulsive harmonic walls.</li>
<li style="list-style-type: '· ';">The cells can be defined as elastic, such that their size adapts to the system. This enables to run simulations under constant pressure.</li>
<li style="list-style-type: '· ';">Trajectories can now be written in XYZ and PDB file format.</li>
<li style="list-style-type: '· ';">Arestart file is written in each simulation step. With this file, simulations can be restarted to seamlessly continue (useful for batch runs or if the job crashed). Restart is handled via the Restart command; see below.</li>
<li style="list-style-type: '· ';">Introduced regions ( i. e. , subsets of atoms), which can be individually defined. Regions can be used to thermostat different parts of the system to different temperatures ( e. g. , cold solute in hot solvent), or to write subset trajectories of selected atoms.</li>
<li style="list-style-type: '· ';">The energy drift of the simulation is now displayed in every step (in units of Kelvin per atom). Large energy drift can be caused by poor SCF convergence, or by a time step length chosen too large.</li>
<li style="list-style-type: '· ';">Physical units in the MD input are now connected to their numeric values via underscore, such as 350_pm . A whitespace between value and unit is no longer acceptable. This slightly breaks backward compatibility sorry.</li>
</ul>
<ul>
<li style="list-style-type: '· ';">Fixed a bug in the time integration of the equations of motion, which compromised energy conservation.</li>
<li style="list-style-type: '· ';">Fixed crashes for semiempirics and if ECPs were employed. You can now run MD simulations with methods such as PM3 and with ECPs.</li>
</ul>
<h2>7.1.4 Input Format</h2>
<p>The molecular dynamics module is activated by specifying ' MD ' in the simple input line. The actual MD input which describes the simulation follows in the ' %md ' section at some later position in the input file. The contents of this section will subsequently be referred to as 'MD input'.</p>
<pre><code>! MD BLYP D3 def2-SVP %md Timestep 0.5_fs # This is a comment Initvel 350_K Thermostat NHC 350_K Timecon 10.0_fs Dump Position Stride 1 Filename "trajectory.xyz" Run 200 end * xyz 0 1 O -4.54021 0.78439 0.09307 H -3.64059 0.38224 -0.01432 H -4.63463 1.39665 -0.67880 *</code></pre>
<p>Please note that the MD input is not processed by ORCA's main parser, but by a dedicated parser in the MD module. Therefore, the MD input is not required to obey the general ORCA syntax rules. The syntax will be described in the following.</p>
<p>In contrast to general ORCA input, the MD input is not based on keywords, but on commands , which are executed consecutively on a line-by-line basis starting at the top (like, e. g. , in a shell script). This means that identical commands with different arguments may be given, coming into effect when the interpreter reaches the corresponding line. This enables to perform multiple simulations ( e. g. , pre-equilibration and production run) within a single input file:</p>
<pre><code>%md Timestep 1.0_fs Run 200 Timestep 2.0_fs Run 500 end</code></pre>
<p>Work is already under way to add variable definitions, loops, and conditional branching to the MD input. 2 This will enable even larger flexibility ( e. g. , to run a simulation until a certain quantity has converged). The MD input is written in the SANscript language ('Scientific Algorithm Notation Script'), which is under development. A first glimpse can be found at https://brehm-research.de/sanscript</p>
<p>As in standard ORCA input, comments in the MD input are initiated by a ' # ' sign and span to the end of the current line. Commands can be started both at the beginning of a line and after a command. The only place where a ' # ' is not treated as start of a comment is inside of a string literal ( e. g. , in file names).</p>
<pre><code>%md # Comment Timestep 0.5_fs # Comment Dump Position Filename "trajectory#1.xyz" end</code></pre>
<p>Some more MD input syntax rules:</p>
<p>2 Technically speaking, ORCA will then be a Turing-complete script interpreter, such that any computational problem can be solved with ORCA :-)</p>
<ul>
<li style="list-style-type: '· ';">The MDinput is generally not case-sensitive. The only exception are file names on platforms with case-sensitive file systems (such as GNU Linux).</li>
<li style="list-style-type: '· ';">Empty lines are allowed.</li>
<li style="list-style-type: '· ';">Commands and options are separated by space or tabulator characters. Any combination of these characters may be used as separator.</li>
<li style="list-style-type: '· ';">Both DOS and UNIX line break style is acceptable.</li>
</ul>
<h2>Commands</h2>
<p>As already noted above, the central item of the MD input is a command. Each input line contains (at most) one command, and these commands are executed in the given order. A command typically takes one or more arguments, which are given behind the command name, separated by whitespaces, tabulator characters, or commas (optional). The order of the arguments for a command is fixed (see command list in section Command List . Commands may have optional arguments, which are always specified at the end of the argument list, after the last non-optional argument. If there exist multiple optional arguments for a command, not all of them need to be specified; however, they need to be specified in the correct order and without gaps:</p>
<pre><code>%md Command Arg1 Arg2 Arg3 # fine Command Arg1, Arg2, Arg3 # fine Command Arg1 Arg2 Arg3 Optarg1 # fine Command Arg1 Arg2 Arg3 Optarg1 Optarg2 # fine Command Arg1 Arg2 Arg3 Optarg2 # will not work end</code></pre>
<p>Apart from arguments and optional arguments, commands can also have modifiers . These can be considered as 'sub-commands', which modify a given command, and may possess their own argument lists. Modifiers generally follow after all non-optional and optional arguments, and they may not possess optional arguments on their own. If a command has multiple modifiers, the order in which they are given is not important.</p>
<p>In the following input example, ' Mod1 ' and ' Mod2 ' are modifiers of ' Command '. ' Mod1 ' takes one argument, ' Mod2 ' does not take arguments:</p>
<pre><code>%md Command Arg1 # fine Command Arg1 Optarg1 # fine Command Arg1 Mod1 Modarg1 Mod2 # fine Command Arg1 Mod2 # fine Command Arg1 Mod2 Mod1 Modarg1 # fine Command Arg1 Optarg1 Mod1 Modarg1 Mod2 # fine end</code></pre>
<p>To make this abstract definition a little more illustrative, please consider again one line from the input sample at the beginning of this section:</p>
<pre><code>%md Dump Position Stride 1 Filename "trajectory.xyz" end</code></pre>
<p>Here, ' Dump ' is the command, which takes one non-optional argument to specify which quantity shall be dumped in this case, ' Position '. The ' Dump ' command has two modifiers, namely ' Stride ' and ' Filename '. The former takes one integer argument, the latter a string argument. Swapping the two modifiers (together with their respective arguments, of course) would not change the behavior.</p>
<h2>Separating Arguments</h2>
<p>As shown above, the arguments which are passed to a command do not need to be separated by commas. However, it is allowed (and recommended) to still use commas. First, it can increase the readability of the input file. Secondly, there exist a few ambiguous cases in which commas (or parentheses) should be used to clarify the intended meaning. One of these cases is the arithmetic minus operator. It can either be used as binary operator (subtracting one number from another), or as unary operator (returning the negative of a number). By default, the minus operator will be considered as binary operator (if possible).</p>
<p>Consider the case in which you want to pass two integer arguments ' 10 ' and ' -10 ' to a command. Without commas (or parentheses), the minus is mistreated as binary operator, and only one argument will be passed to the command:</p>
<pre><code>Command 10 -10 # Pitfall: treated as "Command (10 -10)", i.e., "Command 0" Command 10, -10 # Two arguments, as intended Command 10 (-10) # Also works</code></pre>
<h2>Physical Units</h2>
<p>In many cases, it is required to specify quantities which bear a physical unit in an input file ( e. g. , temperature, time step lengths, …). For many quantities, there are different units in widespread use, which always leads to some confusion (just consider the 'kcal vs kJ' case). ORCA handles this problem by defining default units for each quantity and requiring that all quantities are given in their default unit. ORCA's default units are the atomic units, which are heavily used in the quantum chemistry community, but not so much in the molecular dynamics community. As an ab initio molecular dynamics module exists in the small overlap region of both communities, some 'unit conflicts' might arise. To prevent those from the beginning, it is allowed to specify units of personal choice within ORCA's MDinput.</p>
<p>Luckily, this is as simple and convenient as it sounds. The parser of the MD module checks if a unit is given after a numeric constant, and automatically converts the constant to the internal default unit. If no explicit unit is given, the default unit is assumed. Please note that the default units within the MD module are not necessarily atomic units (see table below). Units are connected to the preceding numerical value by an underscore:</p>
<pre><code>%md Timestep 1.0_fs Timestep 41.3_au # identical Timestep 1.0 # identical, as default time unit in MD module is fs end</code></pre>
<p>In the following, all units which are currently known to the MD module's parser are listed, sorted by physical quantities. The default unit for each quantity is printed in bold letters . Additive constant and factor are applied to convert a unit into the default unit. The additive constant is applied before the factor. A ' -' means that the constant/factor is not applied. More units will be probably added in the future.</p>
<table><tbody><tr><th>Unit Symbol</th><th>Additive Constant</th><th>Factor</th></tr><tr><th>-Length Units-</th><td></td><td></td></tr><tr><th>Angstrom</th><td>-</td><td>-</td></tr><tr><th>A</th><td>-</td><td>-</td></tr><tr><th>Bohr</th><td>-</td><td>0.5291</td></tr><tr><th>pm</th><td>-</td><td>0.01</td></tr><tr><th>nm</th><td>-</td><td>10.0</td></tr><tr><th>-Time Units-</th><td></td><td></td></tr><tr><th>fs</th><td>-</td><td>-</td></tr><tr><th>ps</th><td>-</td><td>1000</td></tr><tr><th>au</th><td>-</td><td>0.02419</td></tr><tr><th>-Temperature Units-</th><td></td><td></td></tr><tr><th>Kelvin</th><td>-</td><td>-</td></tr><tr><th>K</th><td>-</td><td>-</td></tr><tr><th>Celsius</th><td>273.15</td><td>-</td></tr><tr><th>C</th><td>273.15</td><td>-</td></tr><tr><th>-Angle Units-</th><td></td><td></td></tr><tr><th>Deg</th><td>-</td><td>-</td></tr><tr><th>Rad</th><td>-</td><td>180/ π</td></tr></tbody></table>
<h2>7.1.5 Discussion of Features</h2>
<h2>Restarting Simulations</h2>
<p>Ab initio molecular dynamics simulation are computationally expensive, and will typically run for a long time even in the case of medium-sized systems. Often, it is desirable to perform such a simulation as a combination of multiple short runs ( e. g. , if the queuing system of the cluster imposes a maximum job time). The ORCA MD module writes a restart file in each simulation step, which allows for the seamless continuation of simulations. This restart file has the name ' basename.mdrestart ', where basename is the project's base name. To load an existing restart file, use the Restart command (see command list below) .</p>
<p>In the first run of a planned sequence of runs, no restart file exists yet. for this case, the Restart command offers the IfExists modifier. The restart file is only loaded if it exists. If not, the restart is simply skipped, and no error is thrown. By using this modifier, you can have the Restart command already in place in the first run of a sequence (where no restart file exists in the beginning), and do not need to modify the input after the first run has finished.</p>
<p>Concerning the Dump command, it is good to know that trajectory files are appended ( not overwritten) by default. If you ever want to overwrite an existing trajectory file by a Dump command, use the Replace modifier.</p>
<p>Please note that only the positions, velocities, thermostat internal state (only for NHC) , Metadynamics hills, and time step counters are restarted when executing a Restart command. All other properties (thermostats, regions, trajectory dumps, constraints, cells, etc.) are not restarted. They should all remain in the input file, as executed in the first run of a sequence. Just add the Restart command after all other relevant commands have been executed, directly before the Run command.</p>
<p>To conclude this discussion, a short example is given. If the MD input file</p>
<pre><code>%md Timestep 0.5_fs Initvel 300_K Thermostat NHC 300_K Timecon 10.0_fs Dump Position Stride 1 Filename "trajectory.xyz" Restart IfExists</code></pre>
<p>(continues on next page)</p>
<pre><code>Run 100 end</code></pre>
<p>is subsequently executed ten times (without any modification), the resulting trajectory file will be identical (apart from numerical noise) to that obtained if the following input is executed once:</p>
<pre><code>%md Timestep 0.5_fs Initvel 300_K Thermostat NHC 300_K Timecon 10.0_fs Dump Position Stride 1 Filename "trajectory.xyz" Run 1000 end</code></pre>
<h2>Regions</h2>
<p>In the ORCA MD module, regions can be defined. This concept does not refer to regions in space, but rather to subsets of atoms in the system. A region is nothing more than a list of atoms. Regions may overlap, i. e. , atoms can be part of more than one region at a time. The atoms which are part of a certain region remain the same until the region is manually re-defined, i. e. , regions are fixed and do not adapt to any changes in the system. There exist a few pre-defined regions which have a name. User-defined regions, in contrast, only carry an integer identifier. The following regions are pre-defined in any case:</p>
<ul>
<li style="list-style-type: '· ';">all : Contains all atoms of the system. This is the default if no region is specified in some commands, so by default, these commands will always act on the whole system.</li>
<li style="list-style-type: '· ';">active : This region contains all movable ('non-frozen') atoms. By default, it is identical to the all region. Atoms inside of this region are updated by the time integration in a molecular dynamics run, displaced in a minimization, and are considered for computing the kinetic energy.</li>
<li style="list-style-type: '· ';">inactive : This region contains all atoms which are not part of the active region. These atoms are 'frozen'; they are ignored by the time integration / minimization, and also not considered for the computation of the kinetic energy. They simply remain on their initial positions. This is in principle identical to applying Cartesian constraints to the atoms; however, it is much faster. As constraints have to be solved iteratively (see below) , Cartesian constraints become quite computationally demanding if applied to thousands of atoms.</li>
</ul>
<p>Fromthese three pre-defined regions, only the active region can be manually modified. Changes in the composition of the active region automatically modify the inactive region. The all region obviously cannot be changed.</p>
<p>In case of a QM/MM simulation, the following four additional regions can be used:</p>
<ul>
<li style="list-style-type: '· ';">qm : This is the 'quantum mechanics' region - it contains all atoms which are treated by the electron structure method.</li>
<li style="list-style-type: '· ';">mm : This is the 'molecular mechanics' region - it contains all atoms which are treated by a force-field approach. It exactly contains those atoms which are not part of the qm region.</li>
<li style="list-style-type: '· ';">active_qm : Contains exactly those atoms which are part of both the qm and the active regions.</li>
<li style="list-style-type: '· ';">active_mm : Contains exactly those atoms which are part of both the mm and the active regions.</li>
</ul>
<p>These regions can not be modified in the MD input. The MD module just reads the region definitions from the QM/MM module, but is not able to make any changes here.</p>
<p>Regions can be useful for many purposes. For example, a 'realistic' wall of atoms can be built around the system by defining the active region such that it only contains the non-wall atoms. The wall atoms will then be frozen. Apart from that, trajectories of regions can be written to disk, only containing the 'interesting' part of a simulation. Furthermore, velocity initialization can be applied to regions, enabling to start a simulation in which different sets of atoms possess different initial temperatures. Thermostats can be attached to regions to keep different sets of atoms at different temperatures during the whole simulation. This allows for sophisticated simulation setups (cold solute in hot solvent, temperature gradient through the system, etc).</p>
<p>(continued from previous page)</p>
<p>Regions are defined or modified by the Manage_Region command. Many other commands take regions as optional arguments. Please see the command list below.</p>
<h2>Metadynamics</h2>
<p>Metadynamics is a powerful tool to analyze free energy profiles of reactions and other processes (solvation, aggregation, conformer change, dissociation) based on molecular dynamics simulations. It has been developed by Laio and Parrinello in 2002 [804]. In principle, the frequency of observing a certain process in MD simulations is directly related to the free energy barrier of the process. However, many interesting processes (such as chemical reactions) possess such a high free energy barrier that they will never occur on the time scales typical for AIMD simulations (100 ps). To increase the frequency at which such processes happen, so-called rare event sampling methods can be employed. Metadynamics is one among those. It works by building up a bias potential as a sum of Gaussian hills, so that free energy minima are slowly filled up and the system is gradually pushed away from its resting points.</p>
<p>Please note that there is also a method with the same name for exploring conformation space that has been published by Grimme in 2019 [814]. It is in principle based on the original 'Parrinello' Metadynamics, but with several modifications and extensions. The ORCA MD module contains the original Parrinello variant of Metadynamics [804], together with several extensions such as well-tempered Metadynamics [808] and extended Lagrangian Metadynamics [805]. The Grimme method for conformer search will probably be implemented in the future.</p>
<p>In Metadynamics, one has to define one or more 'collective variables' (Colvars) along which the free energy profile of the system will be sampled. A Colvar is in principle nothing more than a continuous function of all atom positions which returns a real number. A simple example of a Colvar is the distance between two atoms, which could be used to explore the free energy profile of a bond formation or cleavage. In the ORCA MD module, Colvars can be defined via the Manage_Colvar command. Available Colvar types are distances (including projections onto lines or into planes) , angles, dihedral angles, and coordination numbers [805]. The latter allows, e. g. , to accurately compute p K A values of weak acids in solvent [806, 807]. For the distances, angles, and dihedral angles, atom groups instead of single atoms can be specified, so that, e. g. , the distance between the centers of mass of two molecules can be defined as a Colvar.</p>
<p>Based on one or two Colvars (ORCA supports one-dimensional and two-dimensional Metadynamics), a Metadynamics simulation can be set up. There are many parameters to choose, which are described in the section of the Metadynamics command. After all parameters have been set, the actual simulation is simply started via the Run command. It is also possible to restart Metadynamics simulations so that they can be split into multiple successive runs; see the Restart command. A full example for a two-dimensional well-tempered extended Lagrangian Metadynamics simulation can be found on below .</p>
<p>Note that Metadynamics simulations typically require very much computational time (at least several 10 000 MD steps for a roughly converged result, depending on the Colvar choice) . So this is by no means a method to 'shortly try out'. However, there are no cheaper methods for predicting free energy profiles (apart from very simple approximations such as the harmonic oscillator) , and the predictive power of computing free energy profiles comes at a price.</p>
<h2>7.1.6 Command List</h2>
<p>In Table 7.1, an alphabetical list of all commands currently known to the MD module is given. The description of each command starts with a small box which contains the command's name and a table of arguments and modifiers. The last-but-one column in the table specifies the type of each argument. Possible types are 'Integer', 'Real', 'String', and 'Keyword'. In the latter case, the last column contains a list of allowed keyword values in { braces }. If the type is 'Real' and is a physical quantity with unit, the quantity is given in the last column in [square brackets]. Each such box is followed by a textual description of the corresponding command.</p>
<p>Table 7.1: Overview of commands in the %md block</p>
<p>Cell</p>
<table><tbody><tr><th colspan="2">Manadory Arguments:</th><td>-</td><td></td><td></td></tr><tr><th colspan="2">Optional Arguments:</th><td>-</td><td></td><td></td></tr><tr><th rowspan="12">Modifiers:</th><th>Cube</th><td>…</td><td>…</td><td>see text</td></tr><tr><th>Rect</th><td>…</td><td>…</td><td>see text</td></tr><tr><th>Rhomb</th><td>…</td><td>…</td><td>see text</td></tr><tr><th>Sphere</th><td>…</td><td>…</td><td>see text</td></tr><tr><th>Ellipsoid</th><td>…</td><td>…</td><td>see text</td></tr><tr><th>None</th><td>-</td><td>-</td><td>-</td></tr><tr><th>Spring</th><td>k</td><td>Real</td><td>see text</td></tr><tr><th>Elastic</th><td>t avg</td><td>Real</td><td>[time]</td></tr><tr><td></td><td>c response</td><td>Real</td><td>see text</td></tr><tr><th>Anisotropic</th><td>-</td><td>-</td><td>-</td></tr><tr><th>Pressure</th><td>…</td><td>…</td><td>see text</td></tr><tr><th>Fixed</th><td>-</td><td>-</td><td>-</td></tr></tbody></table>
<p>Defines a harmonic repulsive wall around the system (the wall is 'soft' with a spring constant and atoms can slightly penetrate; 'hard' repulsive walls are not supported) . This helps to keep the molecules inside of a well-defined volume, or to keep a constant pressure in the system. In the latter case, the cell can be defined as elastic, such that it exerts a well-defined pressure (see below) . Please note that ORCA does not feature periodic boundary conditions, and therefore, all cells are non-periodic (just repulsive walls). There are several cell geometries available (only one type of cell can be active at a time) :</p>
<ul>
<li style="list-style-type: '· ';">Cube : Defines a cubic cell. If two real values p 1 and p 2 are specified as coordinates, the cell ranges from ( p 1 , p 1 , p 1 ) to ( p 2 , p 2 , p 2 ) . If only one real value p is supplied, the cell ranges from ( -p 2 , -p 2 , -p 2 ) to ( p 2 , p 2 , p 2 ) , i. e. it is centered at the origin with edge length p .</li>
<li style="list-style-type: '· ';">Rhomb : Defines a parallelepiped-shaped cell (also termed as rhomboid sometimes). You have to specify twelve real values in total. The first three define one corner point p of the cell, and the remaining nine define three cell vectors v 1 , v 2 , and v 3 , each given as Cartesian vector components. The cell is then defined as the set of points { p + c 1 v 1 + c 2 v 2 + c 3 v 3 | 0 ≤ c 1 , c 2 , c 3 ≤ 1 } The vectors v 1 , v 2 , and v 3 do not need to be orthogonal to each other, but they may not all lie within one plane (cell volume would be zero).</li>
<li style="list-style-type: '· ';">Rect : Defines an orthorhombic cell. Six real values x 1 , y 1 , z 1 , x 2 , y 2 , and z 2 have to be specified as coordinates (in this order) . The cell will range from ( x 1 , y 1 , z 1 ) to ( x 2 , y 2 , z 2 ) .</li>
</ul>
<table><tbody><tr><th>Command</th><th>Description</th></tr><tr><td>Cell</td><td>Defines and modifies cells</td></tr><tr><td>Constraint</td><td>Manages constraints</td></tr><tr><td>Dump</td><td>Controls trajectory output</td></tr><tr><td>Initvel</td><td>Randomly initializes atom velocities</td></tr><tr><td>Manage_Colvar</td><td>Manages collective variables (&#x27;Colvars&#x27;)</td></tr><tr><td>Manage_Region</td><td>Manages regions</td></tr><tr><td>Metadynamics</td><td>Sets parameters for Metadynamics runs</td></tr><tr><td>Minimize</td><td>Performs a Cartesian energy minimization</td></tr><tr><td>PrintLevel</td><td>Controls the output verbosity</td></tr><tr><td>Randomize</td><td>Sets the random seed</td></tr><tr><td>Restart</td><td>Restarts a simulation to seamlessly continue</td></tr><tr><td>Restraint</td><td>Manages restraints on Colvars</td></tr><tr><td>Run</td><td>Performs a molecular dynamics run</td></tr><tr><td>SCFLog</td><td>Controls the ORCA log file output</td></tr><tr><td>Screendump</td><td>Prints current MDstate to screen</td></tr><tr><td>Thermostat</td><td>Manages thermostats</td></tr><tr><td>Timestep</td><td>Sets the integrator time step ∆ t</td></tr></tbody></table>
<ul>
<li style="list-style-type: '· ';">Sphere : Defines a spherical cell. You need to specify four real values c x , c y , c z , and r . The cell will then be defined as a sphere around the central point ( c x , c y , c z ) with radius r .</li>
<li style="list-style-type: '· ';">Ellipsoid : Defines an ellipsoid-shaped cell. As first three arguments, you have to specify three real values c x , c y , c z , which define the center of the ellipsoid to be ( c x , c y , c z ) . As fourth argument, a keyword has to follow, which may either be ' XYZ ' or ' Vectors '. In the ' XYZ ' case, three more real values r x , r y , and r z have to be specified, which define the partial radii of the ellipsoid along the X, Y, and Z coordinate axes. If instead ' Vectors ' was given, nine more real values v 1 x , v 1 y , v 1 z , v 2 x , v 2 y , v 2 z , v 3 x , v 3 y , v 3 z have to follow after the keyword. These values define three vectors v 1 := ( v 1 x , v 1 y , v 1 z ) , v 2 := ( v 2 x , v 2 y , v 2 z ) , and v 3 := ( v 3 x , v 3 y , v 3 z ) , which are the principal axes of the ellipsoid. These vectors have to be strictly orthogonal to each other. The length of each vector defines the partial radius of the ellipsoid along the corresponding principal axis.</li>
</ul>
<p>All cell types define a harmonic potential E cell ( r ) := k · r 2 which acts on all atoms in the system outside of the cell , where r is the closest distance from the atom's center to the defined cell surface. Atoms whose center is inside of the cell or directly on the cell surface do not experience any repulsive force. Following from the definition, the force which acts on an atom outside of the cell is always parallel to the normal vector of the cell surface at the point which is closest to the atom center. This is trivial in case of cubic, rectangular, rhombic, and spherical cells, but not so trivial for ellipsoid-shaped cells.</p>
<p>The spring constant k in the above equation ( i. e. , the 'steepness' of the wall) can be specified by the ' Spring ' modifier, which expects one real value as argument. The spring constant has to be specified in the unit kJ mol -1 Å -2 , other units cannot be specified here. The default value is 10 kJ mol -1 Å -2 . Larger spring constants reduce the penetration depth of atoms into the wall, but may require shorter integration time steps to ensure energy conservation. If jumps in the total energy occur, try to use a smaller spring constant ( e. g. , the default value).</p>
<p>The command ' Cell None ' disables any previously defined cell.</p>
<p>If you want to perform simulations under constant pressure, you can define an elastic cell. Then, ORCA accumulates the force which the cell exerts on the atoms in each time step, and divides this total force by the cell surface area to obtain a pressure. As this momentarily pressure heavily fluctuated, a running average is used to smooth this quantity. If the averaged pressure is larger than the external pressure which was specified, the cell will slightly grow; if it was smaller, the cell will slightly shrink. In the beginning of a simulation, the cell size will not vary until at least the running average history depth of steps have been performed.</p>
<p>An elastic cell is enabled by using the ' Elastic ' modifier after the cell geometry definition. Subsequently, two real values t avg and c response are required. While t avg defines the length of the running average to smooth the pressure (in units of physical time, not time steps) , the c response constant controls how fast the cell size will change at most. More specific, c response is the fraction of the cell volume growth per time step if the ratio of averaged and external pressure would be infinite, and at the same time the fraction of the cell volume reduction per step if the aforementioned ratio is zero. Put into mathematical form, the cell volume change per time step is</p>
<div class="formula-not-decoded">Formula not decoded</div>
<p>where ⟨ p ⟩ represents the averaged pressure the system exerts on the walls, and p ext is the specified external pressure. Good starting points are t avg = 100 fs and c response = 0 . 001 . Please note that larger values of c response or smaller values of t avg may lead to uncontrolled fluctuations of the cell size. An already defined fixed cell can be switched to elastic by the command ' Cell Elastic ... ' (the dots represent the two real arguments).</p>
<p>By default, the size change of an elastic cell due to pressure is performed isotropically , i. e. , the cell is scaled as a whole, and exactly retains its aspect ratio. By specifying the ' Anisotropic ' modifier after switching on an elastic cell, the cell pressure is broken down into individual components, and the size of the cell is allowed to change independently in the individual directions. This, of course, only makes sense for the cell geometries Rect , Rhomb , and Ellipsoid . An already defined isotropic cell can be switched to anisotropic by simply executing ' Cell Anisotropic '.</p>
<p>In case of an elastic cell, the external pressure is defined by the modifier ' Pressure ', which expects either one or three real values as arguments. If one argument is given, this is the isotropic external pressure. If three arguments are supplied, these are the components of the pressure in X, Y, and Z direction (in case of orthorhombic cells) or along the direction of the three specified vectors (in case of parallelepiped-shaped and ellipsoid-shaped cells) . This allows for anisotropic external pressure (probably only useful for solid state computations). Both the pressure and the pressure</p>
</div>
</body>
</html>